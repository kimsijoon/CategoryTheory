---
description: Preface
---

# 서론

> 프로그래머를 대상으로 하는 범주론 책을 쓸까 하는 생각을 한지는 좀 되었습니다. 컴퓨터 과학자가 아니라 프로그래머를 대상으로 하는 책 말입니다. 과학자가 아닌 공학자죠. 말도 안되는 생각 같아 보일 수도 있습니다. 저도 약간 무섭거든요. 저는 과학과 공학, 두 분야에서 모두 일해 본 적이 있기 때문에 이 둘 사이에 커다란 간격이 존재한다는 것은 부정할 수 없습니다. 하지만 저는 항상 여러 가지를 설명하고자 하는 아주 강한 충동을 느껴왔습니다. 저는 간단한 설명의 대가인 리처드 파인만\(Richard Feynman\)을 굉장히 존경합니다. 물론 제가 파인만이 아니라는 것은 알고 있어요. 그래도 저는 최선을 다할 것입니다. 범주론을 배우려는 독자들에게 의욕을 불어넣어 주기 위해 쓴 이 서문으로 그 첫걸음을 내딛고자 합니다. 논의를 시작하고 피드백을 받을 수 있기를 바라면서요.

앞으로 몇 문단동안, 저는 이 책의 독자 여러분에게 과연 "남는 시간"에 수학에서 가장 추상적인 분야를 배워야 하는가에 대해 가질 수 있는 반대 의견이 근거가 없다는 것을 설명하고자 합니다.

저는 몇 가지 관찰을 통해 이러한 낙관적인 생각을 가지게 되었습니다. 첫째, 범주론은 아주 유용한 프로그래밍 기술을 담은 보물이라고 할 수 있습니다. 하스켈\(Haskell\) 프로그래머들은 오랫동안 범주론을 이용해왔고, 그 아이디어는 천천히 다른 언어에도 스며들고 있습니다. 하지만 그 속도는 매우 느리기에, 박차를 가할 필요가 있습니다.

둘째, 수학에는 아주 많고 다양한 분야가 있고, 그 분야는 서로 다른 사람들에게 매력을 선사합니다. 독자 여러분이 미적분학이나 대수학을 혐오할 수도 있지만, 그렇다해도 범주론을 즐기지 못한다는 것은 아닙니다. 범주론은 특히 프로그래머의 사고방식에 잘 맞는 수학 분야라고까지 저는 말할 수 있겠습니다. 왜냐하면 범주론은 세부사항이 아닌 구조를 다루기 때문입니다. 범주론은 프로그램이 합성될 수 있도록 만드는 구조의 종류를 다룹니다.

**합성\(Composition\)**은 범주론의 근간입니다. 범주라는 개념 자체의 정의의 일부이지요. 그리고 저는 합성은 프로그래밍의 핵심이라고 강하게 생각합니다. 우리는 오랫동안 여러가지 것들을 합성해 왔습니다. 아주 예전에 어떤 위대한 공학자가 서브루틴\(subroutine\)이라는 개념을 생각해 냈습니다. 얼마 전에는 구조적 프로그래밍 원칙이 코드 블록을 합성 가능하게 만듬으로써 프로그래밍에 혁명을 가져왔습니다. 그 후에는 사물을 합성하는 것이 전부라고도 할 수 있는 객체 지향 프로그래밍이 나왔습니다. 함수형 프로그래밍은 함수나 대수적 자료구조를 합성하는 것뿐만 아니라 다른 프로그래밍 패러다임에서는 거의 불가능한 것이었던 동시성\(concurrency\)을 합성 가능하게 만들어 줍니다.

셋째, 저는 수학을 프로그래머가 더 맛있게 느끼도록 만들 수 있는 비밀 무기를 가지고 있습니다. 여러분이 전문 수학자라면, 가정을 바르게 세우고 모든 선언에 정확하게 단서를 달며 모든 정의를 엄밀하게 구성하는 데 매우 주의를 기울여야 합니다. 이런 것들은 수학 논문과 책을 바깥 사람들이 읽기에 매우 어렵게 만듭니다. 저는 물리학을 전공했고, 물리학에서는 격식에 얽매이지 않는 추론을 통해 놀라운 성과를 만들기도 합니다. 수학자들은 위대한 물리학자인 디락\(P. A. M. Dirac\)이 어떤 미분방정식을 풀기 위해 즉석에서 고안해 낸 디락 델타 함수를 보고 비웃었지만, 디락의 통찰을 형식화한 완전히 새로운 미적분학의 분야인 분포론\(distribution theory\)을 발견하고는 이내 비웃음을 멈추었습니다.

물론, 쉽고 직관적이만 한 논리를 펴다보면 무엇인가를 노골적으로 틀려버릴 수도 있는 위험을 감수해야 합니다. 그래서 저는 이 책에서 격식에 얽매이지 않은 논리 뒤에 탄탄한 수학적 이론이 확실하게 받쳐질 수 있도록 할 것입니다. 제 탁자 위에는 너덜너덜해진 사운더스 맥 레인\(Saunders Mac Lane\)의 _실무 수학자를 위한 범주론\(Category Theory for the Working Mathematician\)_ 책이 놓여 있거든요.

이 책이 '프로그래머'를 위한 범주론이기 때문에, 저는 모든 주요한 개념들을 컴퓨터 코드로 표현하려고 합니다. 함수형 언어가 보다 더 널리 쓰이는 명령형 언어보다 더 수학에 가깝다는 것을 아마 알게 될 것입니다. 또한, 함수형 언어에서는 더 추상적인 힘을 느낄 수 있을 것입니다. 그래서 자연스럽게 '범주론의 힘을 완전히 얻기 전에 하스켈\(Haskell\)을 배워야겠다'고 생각하게 될 것입니다. 그러다보면 범주론이 함수형 언어 이외에는 응용분야가 없다고 은연중에 느낄 수도 있지만, 그야말로 그렇지 않습니다. 그래서 저는 C++로 된 예제를 많이 제공할 것입니다. 당연히, 좀 못생긴 문법을 감수해야 하고, 장황함에 가려 패턴이 눈에 띄지 않을 수도 있으며, 높은 수준의 추상적 개념을 접하기 보다는 그저 복사 붙여넣기를 해야할 수도 있습니다. 하지만 C++ 프로그래머가 다 그런 것이죠.

하지만, 하스켈이 있다면 여러분은 곤경에서 벗어날 수는 있을 것입니다. 하스켈 프로그래머가 될 필요는 없지만, C++로 구현된 아이디어를 그리고 기록하기 위한 언어로 하스켈이 필요할 것입니다. 제가 바로 이렇게 하스켈에 입문했습니다. 하스켈의 간결한 문법과 강력한 자료형 체계\(type system\)는 C++ 템플릿과 자료구조, 알고리즘을 이해하는데 아주 큰 도움이 되었습니다. 하지만 모든 독자들이 이미 하스켈을 알 것이라고 생각할 수는 없기 때문에, 저는 이 모든 것들을 천천히 소개하고 설명하고자 합니다.

여러분이 경력 있는 프로그래머라면, '나는 지금까지 범주론이나 함수형 메소드 같은 것들은 걱정하지 않고 코딩했는데, 그럼 뭐가 달라지는거야?'라고 물으실지도 모르겠습니다. 분명히 여러분도 명령형 언어에 새로운 함수형 기능들이 꾸준히 들어오는 흐름이 있는 것을 알아채지 않을 수 없을 것입니다. 심지어 객체 지향 프로그래밍의 보루인 자바\(Java\)에도, 람다\(lambda\)가 도입되었습니다. C++은 최근에 몇년마다 새로운 표준이 나오는 등 정신없이 진화하면서 변화하는 세계에 발맞추고자 하고 있습니다. 이러한 모든 움직임이, 물리학에서는 상 전이\(phase transition\)이라고도 표현하는, 혁신적인 변화를 위한 준비입니다. 물을 계속 데우다보면, 결국 끓기 시작할 것입니다. 우리는 지금 계속 뜨거워지고 있는 물에서 계속 수영할 것인지, 아니면 다른 대안을 찾기 시작할 것인지 결정해야 하는 개구리의 위치에 있습니다.

![](../.gitbook/assets/preface-1.jpg)

멀티코어 혁염은 이러한 큰 변화를 주도하는 힘 가운데 하나입니다. 널리 쓰이는 프로그래밍 패러다임인 객체 지향 프로그래밍은 동시성과 병렬성의 영역에 발을 들여놓게 하지 않습니다. 대신에, 위험하고 버그가 많은 디자인을 채택하게 하죠. 객체 지향의 기본적인 전제인 자료 은닉\(data hiding\)은 자료의 공유와 변이와 합쳐졌을 때, 자료의 경쟁상태\(data race\)를 야기합니다. 뮤텍스\(mutex\)를 사용하여 자료를 보호한다는 아이디어는 훌륭하지만, 이러한 락\(lock\)은 안타깝게도 합성할 수 없습니다. 또한 락을 통한 은닉은 데드락\(deadlock\)을 더 쉽게 만들어 디버그하기 어렵게 만듭니다.

하지만 동시성을 끌어들이지 않더라도, 명령형 패러다임은 소프트웨어 시스템의 복잡성 증가로 인해 그 확장성의 한계를 시험받고 있습니다. 간단히 말해서, 부수 효과\(side effects\)는 통제 범위에서 벗어나고 있다는 것입니다. 물론, 부수 효과를 가지는 함수는 자주 편리하고 쓰기 쉽습니다. 그 부수 효과는 이론적으로 함수 이름이나 주석에 표시할 수 있습니다. SetPassword나 WriteFile과 같은 함수는 명백하게 특정한 상태를 바꾸고 부수 효과를 만듭니다. 그리고 우리는 이러한 것들을 다루는 데 익숙합니다. 부수 효과가 있는 함수를 함수 위에 부수 효과가 있는 다른 함수를 합성하고, 또 합성하기 시작하면, 점점 사안은 아슬아슬해지기 시작할 것입니다. 부수 효과가 본질적으로 나쁘다는 것이 아닙니다. 보다 큰 스케일에서 관리되기 어렵게 만드는 것들이 눈에 보이지 않게 숨겨져 있다는 뜻입니다. 부수 효과는 크기를 키울 수 없습니다. 그리고, 명령형 프로그래밍은 전부 부수 효과를 다루는 것입니다.

하드웨어의 변화와 소프트웨어의 복잡성 증가로 인해, 우리는 프로그래밍의 토대에 대해 다시 생각하게 되었습니다. 유럽의 위대한 고딕 양식 대성당의 건축가들처럼, 우리는 그저 재료와 구조의 한계에 맞춰 기술을 연마하고 있었습니다. 프랑스의 보베\(Beauvais\)에는 완공되지 않은 고딕 양식 대성당이 있습니다. 이 성당은 한계를 지닌 인간의 깊은 투쟁을 보여주는 증거입니다. 이 성당은 애초에 그 이전의 모든 높이와 밝기 기록을 깨려는 계획으로 지어졌습니다만, 여러 번 붕괴로 고통받았습니다. 철근이나 나무 지지대 같은 임시방편\(Ad hoc\)으로 무너지는 것을 막으려 했습니다. 하지만 역시나 많은 문제가 생겼습니다. 현대적인 관점에서는 수많은 고딕 양식 구조물들이, 현대 재료과학, 컴퓨터 모델링, 유한요소분석, 일반 수학과 물리학의 도움 없이 성공적으로 완성되었다는 것이 가히 기적이라 할만 합니다.

![&#xBCF4;&#xBCA0; &#xB300;&#xC131;&#xB2F9;&#xC758; &#xBD95;&#xAD34;&#xB97C; &#xB9C9;&#xAE30; &#xC704;&#xD55C; &#xC784;&#xC2DC;&#xBC29;&#xD3B8;](../.gitbook/assets/preface-2.jpg)

저는 미래 세대들이, 복잡한 운영체제나 웹 서버, 인터넷 인프라를 구축하는데 우리가 사용한 프로그래밍 기술에 감탄하기를 바랍니다. 그리고 솔직히, 그래야만 합니다. 이 모든 것들이 매우 엉성한 이론적 토대 위에서 이루어졌기 때문이죠. 우리가 앞으로 더 나아가기를 원한다면 이러한 토대를 고쳐야만 할 것입니다.

