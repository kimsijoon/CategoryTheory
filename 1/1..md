---
description: 'Category: The Essence of Composition'
---

# 1. 합성의 핵심, 범주

**범주\(Category; 範疇\)**는 알고보면 너무 단순한 개념입니다. 범주는 **대상\(Object\)**과 그 사이를 연결하는 **화살표\(Arrow\)**로 이루어져 있습니다. 그렇기 때문에 범주 그림으로도 표현하기 쉽습니다. 대상은 원이나 점으로 그릴 수 있고, 화살표는.. 그냥 화살표로 그릴 수 있습니다. 하지만 그 범주의 핵심은 바로 **합성\(Composition\)**입니다. 아니면, 합성의 핵심이 범주라고도 할 수 있습니다. 화살표는 합성됩니다. 다시 말해, A 대상에서 B 대상으로 가는 화살표가 있고, B 대상에서 C 대상으로 가는 화살표가 있다면, 반드시 A 대상에서 C 대상으로 가는 '합성'된 화살표가 존재합니다.

### 1.1 함수로서의 화살표

이미 너무 추상적이고 말도 안되는 말 같은가요? 절망하지 마세요. 구체적인 얘기를 해봅시다. 여기서 화살표는 **사상\(Morphism; 寫像\)**이라고도 부를 수 있습니다. 이 화살표를 함수라고 생각해 봅시다. _A_ 자료형을 인자로 받아 _B_ 를 반환하는 함수 _f_ 가 있다고 합시다. 또, _B_ 를 받아 _C_ 를 반환하는 또다른 함수 _g_ 가 있다고 합시다. 이제 _f_ 의 반환값을 _g_ 에 전달하는 것으로 이 두 함수를 합성할 수 있습니다. 이렇게 _A_ 를 받아 _C_ 를 반환하는 새로운 함수를 정의한 것입니다.

![&#xBC94;&#xC8FC;&#xB860;&#xC5D0;&#xC11C;&#xB294; A&#xC5D0;&#xC11C; B&#xB85C; &#xAC00;&#xB294; &#xD654;&#xC0B4;&#xD45C;&#xAC00; &#xC788;&#xACE0;, B&#xC5D0;&#xC11C; C&#xB85C; &#xAC00;&#xB294; &#xD654;&#xC0B4;&#xD45C;&#xAC00; &#xC788;&#xC73C;&#xBA74; &#xC774; &#xB458;&#xC758; &#xD569;&#xC131;&#xC778; A&#xC5D0;&#xC11C; C&#xB85C; &#xC9C1;&#xC811; &#xAC00;&#xB294; &#xD654;&#xC0B4;&#xD45C; &#xB610;&#xD55C; &#xBC18;&#xB4DC;&#xC2DC; &#xC874;&#xC7AC;&#xD569;&#xB2C8;&#xB2E4;. &#xC774; &#xADF8;&#xB9BC;&#xC740; &#xCD94;&#xD6C4;&#xC5D0; &#xB098;&#xC62C; &#xD56D;&#xB4F1;&#xC0AC;&#xC0C1;&#xC774; &#xC5C6;&#xAE30; &#xB54C;&#xBB38;&#xC5D0; &#xC644;&#xC804;&#xD55C; &#xBC94;&#xC8FC;&#xB97C; &#xB098;&#xD0C0;&#xB0B4;&#xB294; &#xAC83;&#xC740; &#xC544;&#xB2D9;&#xB2C8;&#xB2E4;.](../.gitbook/assets/1-1.jpg)

수학에서는 이러한 합성을 _g ∘ f_ 처럼 함수 사이의 작은 원으로 나타냅니다. 합성의 순서가 오른쪽에서 왼쪽이라는 사실에 주목하세요. 어떤 사람들에게는 이게 헷갈릴 수도 있습니다. 유닉스\(Unix\)에서 쓰이는 다음과 같은 파이프 표기나 F\#에서의 꺽쇠 표시 &gt;&gt;에 친숙하다면 말이에요. 이 표기들은 모두 왼쪽에서 오른쪽으로 가는 방향입니다. 하지만 수학이나 하스켈에서는 함수가 오른쪽에서 왼쪽으로 합성됩니다. _g ∘ f_ 를 "_g_ 가 _f_ 의 결과를 받는다"라고 읽으면 도움이 될지도 모르겠어요.

```text
lsof | grep Chrome
```

이제 C 코드를 조금 짜 보면서 더 명확하게 살펴봅시다. A 자료형을 인자로 받아 B 자료형을 가지는 값을 반환하는 함수 f가 있다고 합시다.

```c
B f(A a);
```

그리고 또 다른 함수가 있습니다.

```c
C g(B b);
```

이 둘의 합성은 다음과 같습니다.

```c
C g_after_f(A a)
{
    return g(f(a));
}
```

여기서 다시 한 번, 오른쪽에서 왼쪽으로 가는 합성 g\(f\(a\)\)를 이번에는 C에서 볼 수 있습니다.

C++ 스탠다드 라이브러리에 두 함수를 받아 그 합성을 반환하는 템플릿이 있다고 말할 수 있으면 좋겠지만, 없습니다. 그러니 하스켈을 한 번 도전해 봅시다. 아래는 A에서 B로 가는 함수의 선언입니다.

```haskell
f :: A -> B
```

비슷하게,

```haskell
g :: B -> C
```

이 둘의 합성은 다음과 같습니다.

```haskell
g . f
```

하스켈이 얼마나 간단하게 표현할 수 있는지를 보고나니, C++에서 단순한 함수형 개념을 표현하는 방식은 다소 어색하기까지 합니다. 사실, 하스켈에서는 유니코드 문자를 사용할 수도 있기때문에 합성을 아래와 같이 쓸 수도 있습니다.

```haskell
g ∘ f
```

심지어 유니코드의 더블콜론과 화살표도 쓸 수 있습니다.

```haskell
f ∷ A → B
```

자 이제 첫번째 하스켈 강의입니다. 더블콜론은 "~가 ~ 자료형을 가지고 있다"라는 뜻입니다. 함수형은 두 자료형 사이에 화살표를 넣어서 만들 수 있습니다. 두 함수는 사이에 온점이나 유니코드 원을 넣어서 합성할 수 있습니다.

### 1.2 합성의 성질

모든 범주의 합성이 만족해야 하는 두 가지 아주 중요한 성질이 있습니다.

1. 합성은 결합법칙이 성립합니다. _f_, _g_, _h_ 라는 세 사상을 합성한다면 \(즉, 이들의 한쪽 끝 대상이 다른 쪽 끝 대상과 맞을 것입니다\), 합성을 위해 괄호가 필요하지 않습니다. 수학적 표기로는 다음과 같이 나타낼 수 있습니다.

$$
h  \circ (g \circ f) = (h \circ g) \circ f = h \circ g \circ f
$$

\(의사\)하스켈로는 다음과 같습니다.

```haskell
f :: A -> B
g :: B -> C
h :: C -> D
h . (g . f) == (h . g) . f == h . g . f
```

\(의사\(pseudo\)라고 표현한 이유는, 함수에 대해서 등호가 정의되지 않기 때문입니다.\)

결합법칙은 함수에 있어서는 아주 자명하지만, 다른 범주에 있어서는 자명하지 않을 수 있습니다.

2. 모든 대상 _A_ 에 대해, 합성의 단위인 화살표가 존재합니다. 이 화살표는 그 대상에서 자기 자신으로 향합니다. 합성의 단위가 된다는 것은, _A_ 에서 시작되거나 _A_ 로 끝나는 모든 화살표와 각각 합성될 때 동일한 화살표를 돌려준다는 것을 의미합니다. _A_ 대상의 단위 화살표는 $$id_A$$ \(_A_ 의 **항등원\(identitiy; 恒等元\)**\)라고 표기합니다. 수학적 표기로는 _f_ 가 _A_ 에서 _B_ 로 갈 때, 다음과 같이 나타낼 수 있습니다.

$$
f \circ id_A = f
$$

그리고,

$$
id_B \circ f = f
$$

함수를 다룰 때에는, 항등원 화살표는 인자를 그대로 반환하는 항등함수로 구현할 수 있습니다. 그 구현은 모든 자료형에 대해서 같으므로, 이 함수는 일반적으로 다형성을 가집니다\(polymorphic\).

```cpp
template<class T> T id(T x) { return x; }
```

믈론, C++에서 단순한 것은 없습니다. 무엇을 전달하는지 뿐만 아니라 어떻게 전달해야하는지도 신경써야 하기 때문이죠 \(즉, 값으로 전달하는지, 참조로 전달하는지, 상수 참조로 전달하는지, 이동시켜 전달하는지 등등\).

하스켈에서는, 항등함수가 스탠다드 라이브러리\(Prelude\)에 포함되어 있습니다. 아래는 그 선언과 정의입니다.

```haskell
id :: a -> a
id x = x
```

보이는 바와 같이, 하스켈에서는 다형 함수를 나타내기 아주 쉽습니다. 이 선언에서, 자료형을 그저 자료형 변수\(type variable\)로 대체하였습니다. 여기서, 구체적인 형의 이름은 항상 대문자로 시작하고, 형 변수의 이름은 소문자로 시작합니다. 그러므로 여기서 a는 모든 형을 나타냅니다.

하스켈 함수 정의는 함수 이름과 그 뒤의 형식 인자\(formal parameter\)로 구성됩니다. 여기서 형식 인자는 딱 하나 x입니다. 함수의 몸통은 등호로 구성되어있습니다. 이 간결함은 처음 보는 사람들에게 가끔 충격을 안겨주지만, 이게 완벽하게 말이 된다는 것을 빠르게 확인할 수 있을 것입니다. 함수 정의와 함수 호출은 함수형 프로그래밍에서 가장 기본적인 것입니다. 그래서 그 문법은 최소한으로 간소화되어 있습니다. 인자 리스트 옆에 괄호가 없을 뿐만 아니라, 인자 사이에 쉼표도 없습니다. \(나중에 나올, 여러 개의 인자를 가지는 함수를 정의할 때\)

함수의 몸통은 항상 표현으로 구성됩니다. 즉, 함수에는 선언이 없습니다. 함수의 결과는 이 표현입니다. 여기서는 그냥 x이지요.

여기서 우리의 두 번째 하스켈 강의의 결론이 나옵니다.

항등원 조건은 의사하스켈로 다음과 같이 쓸 수 있습니다.

```haskell
f . id == f
id . f == f
```

여기서 '왜 아무것도 안하는 함수인 항등함수를 가지고 고통받는거지?'라고 물으실지도 모르겠습니다. 여기서 반문하겠습니다. 왜 우리는 숫자 0을 가지고 고통받는 것일까요? 0은 아무것도 없다는 것을 나타냅니다. 고대 로마인들은 0이 없는 수 체계를 가지고도 오늘날까지도 남아있는 훌륭한 도로와 수로를 건설할 수 있었습니다.

0이나 **id**같은 중립적인 값들은 상징적인 변수를 다룰 때 매우 유용합니다. 0의 개념에 익숙했던 아랍인이나 페르시아인들에 비해 로마인들이 대수학을 그리 잘하지 못했던 이유가 그 때문입니다. 항등함수는 고차함수의 인자나 반환값이 될 때 매우 편리합니다. 고차함수는 함수를 상징으로서 다룰 수 있도록 해주는 것입니다. 즉, 함수의 대수학인 것입니다.

요약하자면, 범주는 대상과 화살표\(사상\)로 구성됩니다. 화살표는 합성될 수 있으며, 합성은 결합법칙이 성립합니다. 모든 대상은 합성의 단위로 작용하는 항등원 화살표를 가집니다.

### 1.3 합성은 프로그래밍의 핵심이다

함수형 프로그래밍에서는 문제에 접근하는데 특이한 방법을 사용합니다. 마치 불교적인 질문을 던지면서 시작합니다. 예를 들어, 상호작용형 프로그램을 만들 때, '상호작용이란 무엇인가?'라고 묻습니다. 콘웨이\(Conway\)의 라이프 게임\(Game of Life\)를 구현할 때에는, 아마 삶의 의미에 대해서 고민할 것입니다. 이러한 느낌으로, 저는 묻고 싶습니다. '프로그래밍이란 무엇인가?' 아주 기본적인 수준에서는, 프로그래밍이란 컴퓨터에게 무엇을 할 것인지를 말해 주는 것입니다. "메모리 주소 x의 내용을 읽어서 EAX 레지스터의 내용에 더해라"처럼 말이죠. 하지만 심지어 어셈블리어로 프로그램을 만들 때에도, 컴퓨터에게 주는 지시는 무언가 더욱 의미있는 표현입니다. 우리는 자명하지 않은 문제를 풉니다. \(만약 자명하다면 컴퓨터가 필요하지도 않겠지요.\) 우리는 문제를 어떻게 푸나요? 우리는 큰 문제를 작은 문제로 분해합니다. 분해된 문제가 아직도 크다면, 그 문제를 더 분해하기를 계속합니다. 마지막으로, 우리는 모든 이렇게 분해된 작은 문제들을 푸는 코드를 짭니다. 여기서 프로그래밍의 핵심이 나옵니다. 우리는 이러한 코드 덩어리들을 더 큰 문제의 답을 만들기 위해 합성합니다. 분해한다는 것은 다시 합성할 수 없다면 아무 소용이 없을 것입니다.

이러한 계층적인 분해와 재합성 과정은 컴퓨터 때문에 필요한 작업이 아닙니다. 이것은 사람 머리의 한계로 인한 것입니다. 우리의 뇌는 한 번에 아주 작은 수의 개념밖에 다룰 수 없습니다. 심리학에서 아주 많이 인용된 논문 중, '[마법의 수 칠, 더하거나 빼기 이](http://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two)'라는 논문이 있습니다. 우리는 겨우 7 ± 2 개 "덩어리"의 정보만 우리 머리에 저장할 수 있다고 이 논문은 말합니다. 인간의 단기기억에 대한 우리의 이해는 세세하게 변하고 있을지도 모르지만, 한계가 있다는 것은 확실히 알고 있습니다. 요컨대, 우리는 복잡하게 뒤얽힌 대상이나 스파게티 코드를 다룰 수 없다는 것입니다. 구조가 잘 잡힌 프로그램이 보기 좋아서 우리에게 구조가 필요한 것이 아니라, 그렇지 않으면 우리의 뇌가 효과적으로 처리를 할 수 없기 때문에 필요한 것입니다. 우리는 자주 어떤 코드가 우아하거나 아름답다고 말하지만, 이 말이 진짜로 뜻하는 바는 인간 두뇌의 한계로도 쉽게 처리가 된다는 뜻입니다. 우아한 코드는 우리의 정신적 소화계가 흡수하기에 딱 적당한 크기와 알맞은 수의 덩어리인 것입니다.

그렇다면 프로그램 합성에서 알맞은 덩어리은 무엇인가요? 덩어리의 겉넓이는 부피에 비해 더 천천히 증가합니다. \(저는 이 비유를 좋아합니다. 기하학적인 물체에 있어서 겉넓이는 그 크기의 제곱에 비례하기 때문에 세제곱에 비례하는 부피보다 더 천천히 증가한다는 직관을 보여주기 때문입니다.\) 여기서 겉넓이는 덩어리를 합성하기 위해 필요한 정보이고, 부피는 이 덩어리를 구현하기 위해 필요한 정보입니다. 즉, 덩어리가 한 번 구현되면 구현에 대한 세부사항은 잊어버리고 그 덩어리가 다른 덩어리들과 어떻게 상호작용하는지에만 집중할 수 있게 됩니다. 객체 지향 프로그래밍에서, 겉넓이는 어떤 대상의 클래스의 정의나 그 추상 인터페이스에 해당합니다. 함수형 프로그래밍에서는, 함수의 정의입니다. \(제가 좀 단순화해서 말했지만, 바로 이것이 요점입니다.\)

범주론은 극도로 우리가 어떤 대상들의 안쪽을 들여다보지 못하게 합니다. 범주론에서의 대상은 추상적이고 모호한 것입니다. 우리가 알 수 있는 것은 이 것이 다른 대상과 어떻게 연관되어 있는가, 즉, 화살표로 어떻게 연결되어 있는가 뿐입니다. 인터넷 검색 엔진이 들어갔다가 나오는 링크만을 분석하여 웹사이트의 순위를 매기는 것과 같습니다 \(편법을 쓰지 않는다면요.\). 객체 지향 프로그래밍에서 이상적인 대상은 그 추상 인터페이스를 통해서 화살표의 역할을 하는 메소드들로만 들여다 볼 수 있습니다 \(즉, 부피가 없고 겉만 있는 것과 같습니다\). 어떤 대상이 다른 대상과 합성되는 방법을 알아내기 위해 그 구현을 봐야 하는 순간, 함수형 패러다임의 장점을 잃어버리게 될 것입니다.

